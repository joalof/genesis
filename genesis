#!/usr/bin/env bash

set -e  # Exit on error
set -u  # Exit on undefined variable

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Configuration
readonly LOCAL_DIR="${HOME}/.local"
readonly DOTFILES_REPO="${DOTFILES_REPO:-}"  # Set via environment or prompt
readonly DOTFILES_DIR="${HOME}/.dotfiles"

#==============================================================================
# Utility Functions
#==============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

confirm() {
    local prompt="$1"
    local response
    read -r -p "$prompt [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

#==============================================================================
# Development Tools Installation
#==============================================================================

install_devtools() {
    log_info "Installing development tools..."

    local packages=(
        # Build stuff
        python3
        python-is-python3
        git
        build-essential
        ninja-build
        cmake
        autoconf
        automake
        libtool
        pkg-config
        software-properties-common
        apt-transport-https
        ca-certificates
        gnupg
        lsb-release

        # Utilities
        gettext
        unzip
        curl
        wget
        xstow
        strace
        jq
        ripgrep
        fd-find
        htop
        tree

        # building ghostty
        libgtk-4-dev
        libadwaita-1-dev
        gtk4-layer-shell

        # misc
        keychain 
        feh
        zathura
        ffmpeg
    )

    log_info "Installing: ${packages[*]}"

    sudo apt install -y "${packages[@]}"

    log_success "Development tools installed"
}

#==============================================================================
# Local Directory Structure Setup
#==============================================================================

setup_dir_structure() {
    log_info "Setting up .local directory structure..."

    local directories=(
        "${LOCAL_DIR}/bin"
        "${LOCAL_DIR}/lib"
        "${LOCAL_DIR}/share"
        "${LOCAL_DIR}/include"
        "${LOCAL_DIR}/etc"
        "${LOCAL_DIR}/src"
        "${HOME}/apps"
        "${HOME}/scratch"
        "${HOME}/code"
        "${HOME}/projects"
        "${HOME}/.config"
    )

    for dir in "${directories[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            log_info "Created: $dir"
        else
            log_warning "Already exists: $dir"
        fi
    done
    log_success "Local directory structure setup complete"
}

#==============================================================================
# Dotfiles Setup
#==============================================================================

setup_dotfiles() {
    log_info "Setting up dotfiles..."

    local repo="$DOTFILES_REPO"

    # Prompt for repository if not set
    if [[ -z "$repo" ]]; then
        read -r -p "Enter dotfiles repository URL: " repo
    fi

    if [[ -z "$repo" ]]; then
        log_error "No dotfiles repository provided"
        return 1
    fi

    # Clone or update dotfiles
    if [[ -d "$DOTFILES_DIR" ]]; then
        log_warning "Dotfiles directory already exists at $DOTFILES_DIR"
        if confirm "Update existing dotfiles?"; then
            cd "$DOTFILES_DIR"
            git pull
            log_success "Dotfiles updated"
        fi
    else
        log_info "Cloning dotfiles from $repo"
        git clone "$repo" "$DOTFILES_DIR"
        log_success "Dotfiles cloned"
    fi

    # Run install script if it exists
    local install_script="${DOTFILES_DIR}/install.sh"
    if [[ -f "$install_script" ]]; then
        log_info "Running dotfiles install script..."
        cd "$DOTFILES_DIR"
        chmod +x "$install_script"
        ./"$install_script"
        log_success "Dotfiles installed"
    else
        log_warning "No install.sh script found in dotfiles repository"
    fi
}

#==============================================================================
# Install Scripts Execution
#==============================================================================

check_component_installed() {
    local component_name="$1"

    # Check if the binary exists in PATH
    if command -v "$component_name" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

verify_component_installation() {
    local component_name="$1"
    local category="$2"

    # Check if the binary exists in PATH
    if command -v "$component_name" &> /dev/null; then
        log_success "Verified: $category/$component_name binary found"
        return 0
    else
        log_error "Verification failed: $category/$component_name binary not found in PATH"
        return 1
    fi
}

get_installation_status() {
    local component_name="$1"

    if check_component_installed "$component_name"; then
        echo -e "${GREEN}✓ installed${NC}"
    else
        echo -e "${RED}✗ not installed${NC}"
    fi
}

display_components() {
    local category="$1"
    local category_dir="$2"

    echo ""
    log_info "$category components:"
    echo ""

    local scripts=()
    while IFS= read -r -d '' script; do
        scripts+=("$script")
    done < <(find "$category_dir" -type f -name "install.sh" -print0 | sort -z)

    if [[ ${#scripts[@]} -eq 0 ]]; then
        echo "  No components found"
        return 1
    fi

    local idx=1
    for script in "${scripts[@]}"; do
        local component_name=$(basename "$(dirname "$script")")
        local status=$(get_installation_status "$component_name")
        printf "  %2d) %-20s %s\n" "$idx" "$component_name" "$status"
        ((idx++))
    done

    echo ""
    return 0
}

select_components() {
    local category="$1"
    local category_dir="$2"

    # Get all scripts
    local scripts=()
    while IFS= read -r -d '' script; do
        scripts+=("$script")
    done < <(find "$category_dir" -type f -name "install.sh" -print0 | sort -z)

    if [[ ${#scripts[@]} -eq 0 ]]; then
        return 1
    fi

    # Display components
    display_components "$category" "$category_dir"

    echo "Selection options:"
    echo "  a) Install all"
    echo "  n) Install none"
    echo "  #) Enter component numbers (e.g., 1,3,5 or 1-3 or 1 2 4)"
    echo ""

    local selection
    read -r -p "Select components to install: " selection

    case "$selection" in
        a|A)
            # Return all scripts
            printf '%s\n' "${scripts[@]}"
            return 0
            ;;
        n|N)
            # Return nothing
            return 0
            ;;
        *)
            # Parse selection
            local selected_scripts=()

            # Replace commas with spaces
            selection="${selection//,/ }"

            for item in $selection; do
                if [[ "$item" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                    # Range like 1-3
                    local start="${BASH_REMATCH[1]}"
                    local end="${BASH_REMATCH[2]}"
                    for ((i=start; i<=end; i++)); do
                        if [[ $i -ge 1 && $i -le ${#scripts[@]} ]]; then
                            selected_scripts+=("${scripts[$((i-1))]}")
                        fi
                    done
                elif [[ "$item" =~ ^[0-9]+$ ]]; then
                    # Single number
                    if [[ $item -ge 1 && $item -le ${#scripts[@]} ]]; then
                        selected_scripts+=("${scripts[$((item-1))]}")
                    fi
                fi
            done

            printf '%s\n' "${selected_scripts[@]}"
            return 0
            ;;
    esac
}

install_category_components() {
    local category="$1"
    local interactive="${2:-true}"
    local category_dir="${PWD}/${category}"

    # Check if category directory exists
    if [[ ! -d "$category_dir" ]]; then
        log_warning "No $category directory found at $category_dir"
        return 0
    fi

    # Get selected scripts
    local scripts=()
    if [[ "$interactive" == "true" ]]; then
        while IFS= read -r script; do
            [[ -n "$script" ]] && scripts+=("$script")
        done < <(select_components "$category" "$category_dir")
    else
        # Non-interactive: install all
        while IFS= read -r -d '' script; do
            scripts+=("$script")
        done < <(find "$category_dir" -type f -name "install.sh" -print0 | sort -z)
    fi

    # Check if any scripts were selected
    if [[ ${#scripts[@]} -eq 0 ]]; then
        log_info "No $category components selected for installation"
        return 0
    fi

    log_info "Installing ${#scripts[@]} $category component(s)"

    # Execute each script
    local failed_scripts=()
    for script in "${scripts[@]}"; do
        # Extract component name from path (parent directory name)
        local component_name=$(basename "$(dirname "$script")")

        log_info "Installing $category/$component_name..."

        # Make script executable
        chmod +x "$script"

        # Run the script from its directory
        local script_dir=$(dirname "$script")
        if (cd "$script_dir" && ./install.sh); then
            log_success "Completed: $category/$component_name"

            # Verify installation
            if ! verify_component_installation "$component_name" "$category"; then
                failed_scripts+=("$category/$component_name (verification failed)")
            fi
        else
            log_error "Failed: $category/$component_name"
            failed_scripts+=("$category/$component_name (install failed)")
        fi
    done

    # Report results
    if [[ ${#failed_scripts[@]} -eq 0 ]]; then
        log_success "All $category install scripts completed successfully"
        return 0
    else
        log_error "The following $category components failed:"
        for failed in "${failed_scripts[@]}"; do
            log_error "  - $failed"
        done
        return 1
    fi
}

install_toolchains() {
    local interactive="${1:-true}"
    log_info "Step: Toolchains Installation"
    install_category_components "toolchains" "$interactive"
}

install_apps() {
    local interactive="${1:-true}"
    log_info "Step: Apps Installation"
    install_category_components "apps" "$interactive"
}

#==============================================================================
# Main Execution
#==============================================================================

show_main_menu() {
    echo ""
    echo "========================================"
    echo "        Welcome to Genesis!             "
    echo "========================================"
    echo ""
    echo "1) Complete Installation (all steps)"
    echo "2) Custom Installation (select steps)"
    echo "3) Exit"
    echo ""
}

main() {
    log_info "Starting Genesis setup..."
    echo ""

    # Check if running on Ubuntu or derivative
    if ! grep -qi "ubuntu\|debian\|mint\|pop" /etc/os-release 2>/dev/null; then
        log_warning "This script is designed for Ubuntu-based systems"
        if ! confirm "Continue anyway?"; then
            exit 1
        fi
    fi

    # Show main menu
    show_main_menu
    read -r -p "Select an option [1-3]: " main_choice

    case "$main_choice" in
        1)
            # Complete installation (non-interactive)
            log_info "Running complete installation..."

            echo ""
            log_info "Step: Local Directory Structure"
            setup_dir_structure

            echo ""
            log_info "Updating system packages..."
            sudo apt update
            sudo apt upgrade -y

            echo ""
            log_info "Step: Development Tools Installation"
            install_devtools

            echo ""
            log_info "Step: Dotfiles Setup"
            setup_dotfiles

            echo ""
            install_toolchains "false"

            echo ""
            install_apps "false"
            ;;
        2)
            # Custom installation (interactive)
            log_info "Running custom installation..."
            echo ""

            if confirm "Setup local directory structure?"; then
                echo ""
                log_info "Step: Local Directory Structure"
                setup_dir_structure
            fi

            if confirm "Update system packages?"; then
                echo ""
                log_info "Updating system packages..."
                sudo apt update
                sudo apt upgrade -y
            fi

            if confirm "Install development tools?"; then
                echo ""
                log_info "Step: Development Tools Installation"
                install_devtools
            fi

            if confirm "Setup dotfiles?"; then
                echo ""
                log_info "Step: Dotfiles Setup"
                setup_dotfiles
            fi

            if confirm "Install toolchains?"; then
                echo ""
                install_toolchains "true"
            fi

            if confirm "Install apps?"; then
                echo ""
                install_apps "true"
            fi
            ;;
        3)
            log_info "Exiting..."
            exit 0
            ;;
        *)
            log_error "Invalid option"
            exit 1
            ;;
    esac

    echo ""
    log_success "Genesis setup complete!"
    echo ""
    log_info "You may need to restart your shell or run: source ~/.bashrc"
}

# Run main function
main "$@"
