#!/usr/bin/env python3

from __future__ import annotations

import argparse
import json
import logging
import os
import re
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path

logger = logging.getLogger(__name__)


def confirm(prompt: str) -> bool:
    """Ask the user a yes / no question.

    Args:
        prompt: Text displayed before the [y/N] suffix.

    Returns:
        True when the user answers yes, False otherwise.
    """
    try:
        return input(f"{prompt} [y/N] ").strip().lower() in ("y", "yes")
    except (EOFError, KeyboardInterrupt):
        print()
        return False


def parse_selection(raw: str, count: int) -> list[int]:
    """Convert flexible selection input into zero-based indices.

    Supports single numbers, space/comma-separated lists, and dash ranges.
    Out-of-range values are silently dropped.  Duplicates are removed while
    preserving first-occurrence order.

    Args:
        raw: User input string (e.g. "1,3-5 7").
        count: Number of selectable items (1-based upper bound).

    Returns:
        De-duplicated list of valid zero-based indices.
    """
    indices: list[int] = []
    for token in raw.replace(",", " ").split():
        if m := re.fullmatch(r"(\d+)-(\d+)", token):
            start, end = int(m.group(1)), int(m.group(2))
            indices.extend(i - 1 for i in range(start, end + 1) if 1 <= i <= count)
        elif token.isdigit():
            num = int(token)
            if 1 <= num <= count:
                indices.append(num - 1)
    return list(dict.fromkeys(indices))


@dataclass(frozen=True)
class Application:
    """An installable unit.

    Attributes:
        name: Parent-directory name of the install.sh file.
        script: Absolute path to install.sh.
        dependencies: Names of other components that must be installed first.
        artifacts: Binary names produced by the installer; used for verification.
        platforms: Platform tags this component supports ("linux", "wsl").
    """

    name: str
    script: Path
    dependencies: tuple[str, ...]
    artifacts: tuple[str, ...]
    platforms: tuple[str, ...]

    @property
    def is_installed(self) -> bool:
        """True when every declared artifact exists somewhere on PATH."""
        return all(shutil.which(a) is not None for a in self.artifacts)


def current_platform() -> str:
    """Return 'wsl' when WSL_DISTRO_NAME is set, otherwise 'linux'."""
    return "wsl" if os.environ.get("WSL_DISTRO_NAME") else "linux"


def discover_applications(root_dir: Path) -> list[Application]:
    """Walk a directory and return every install.sh as a Component.

    Each sub-directory that contains an install.sh is expected to also have a
    manifest.json.  When the manifest is missing the component falls back to
    safe defaults (no dependencies, artifact == component name, all platforms).

    Args:
        category_dir: Root directory for one category (e.g. <repo>/apps).

    Returns:
        Components sorted alphabetically by name.
    """
    components: list[Application] = []
    for script in root_dir.rglob("install.sh"):
        if not script.is_file():
            continue
        name = script.parent.name
        manifest_path = script.parent / "manifest.json"
        manifest: dict = (
            json.loads(manifest_path.read_text()) if manifest_path.is_file() else {}
        )
        components.append(
            Application(
                name=name,
                script=script,
                dependencies=tuple(manifest.get("dependencies", [])),
                artifacts=tuple(manifest.get("artifacts", [name])),
                platforms=tuple(manifest.get("platforms", ["linux", "wsl"])),
            )
        )
    return sorted(components, key=lambda c: c.name)


def resolve_order(applications: list[Application]) -> list[Application]:
    """Topological sort so that dependencies install before dependents.

    Only dependencies present in *components* affect ordering; external
    dependencies (already installed or provided by an earlier step) are
    ignored for ordering purposes.  Assumes no circular dependencies.

    Args:
        components: The components to order.

    Returns:
        A new list in a valid install order.
    """
    by_name = {c.name: c for c in applications}
    in_degree = {
        c.name: sum(1 for d in c.dependencies if d in by_name) for c in applications
    }
    dependents: dict[str, list[str]] = {c.name: [] for c in applications}
    for c in applications:
        for d in c.dependencies:
            if d in dependents:
                dependents[d].append(c.name)

    # Kahn's algorithm; sorted queue keeps output deterministic.
    ready = sorted(n for n, deg in in_degree.items() if deg == 0)
    order: list[Application] = []
    while ready:
        name = ready.pop(0)
        order.append(by_name[name])
        for dependent in sorted(dependents[name]):
            in_degree[dependent] -= 1
            if in_degree[dependent] == 0:
                ready.append(dependent)
                ready.sort()
    return order


# ---------------------------------------------------------------------------
# Configuration constants
# ---------------------------------------------------------------------------

#: Canonical step ordering; also the valid --step values.
STEPS: tuple[str, ...] = ("dirs", "sysupgrade", "devtools", "dotfiles", "apps")

#: Prompts shown for each step in custom mode.
STEP_PROMPTS: dict[str, str] = {
    "dirs": "Setup local directory structure?",
    "sysupgrade": "Update system packages?",
    "devtools": "Install development tools?",
    "dotfiles": "Setup dotfiles?",
    "apps": "Install apps?",
}

#: Directories to create under $HOME (relative paths).
HOME_DIRS: tuple[str, ...] = (
    ".local/bin",
    ".local/lib",
    ".local/share",
    ".local/include",
    ".local/etc",
    ".local/src",
    "apps",
    "scratch",
    "code",
    "projects",
    ".config",
)


class Genesis:
    """Orchestrator that owns every bootstrap step.

    Attributes:
        script_dir: Directory containing this script and the category
            sub-directories (toolchains/, apps/).
        local_dir: The ~/.local prefix.
        dotfiles_dir: Clone target for the dotfiles repository.
        packages_file: Path to packages.txt.
    """

    def __init__(self, script_dir: Path) -> None:
        """Initialise Genesis with the script's own directory.

        Args:
            script_dir: Typically Path(__file__).resolve().parent.
        """
        self.script_dir = script_dir
        self.local_dir = Path.home() / ".local"
        self.dotfiles_dir = Path.home() / ".dotfiles"
        self.packages_file = script_dir / "packages.txt"

    def bootstrap(self) -> None:
        """Ensure ~/.local/bin is on PATH and the symfarm symlink exists."""
        bin_dir = str(self.local_dir / "bin")
        if bin_dir not in os.environ.get("PATH", "").split(os.pathsep):
            os.environ["PATH"] = bin_dir + os.pathsep + os.environ.get("PATH", "")
            logger.info("Added %s to PATH for this session", bin_dir)

        if shutil.which("symfarm"):
            logger.info("symfarm executable already exists in PATH")
            return

        target = self.script_dir / "symfarm"
        link = self.local_dir / "bin" / "symfarm"
        if target.is_file():
            link.parent.mkdir(parents=True, exist_ok=True)
            link.unlink(missing_ok=True)
            link.symlink_to(target)
            logger.info("Created symlink: %s -> %s", link, target)
        else:
            logger.warning("Could not find symfarm script to create symlink")

    def setup_dirs(self) -> None:
        """Create the standard directory skeleton under $HOME."""
        logger.info("Setting up .local directory structure...")
        home = Path.home()
        for rel in HOME_DIRS:
            path = home / rel
            if path.is_dir():
                logger.warning("Already exists: %s", path)
            else:
                path.mkdir(parents=True, exist_ok=True)
                logger.info("Created: %s", path)
        logger.info("Local directory structure setup complete")

    def sysupgrade(self) -> None:
        """Run sudo apt update followed by sudo apt upgrade."""
        logger.info("Updating system packages...")
        subprocess.run(["sudo", "apt", "update"], check=True)
        subprocess.run(["sudo", "apt", "upgrade", "-y"], check=True)

    def install_devtools(self) -> None:
        """Read packages.txt and install every listed package via apt.

        Exits with an error log if the file is missing or empty.
        """
        logger.info("Installing development tools...")

        if not self.packages_file.is_file():
            logger.error("Packages file not found: %s", self.packages_file)
            sys.exit(1)

        packages = [
            stripped
            for raw in self.packages_file.read_text().splitlines()
            if (stripped := raw.strip()) and not stripped.startswith("#")
        ]

        if not packages:
            logger.error("No packages found in %s", self.packages_file)
            sys.exit(1)

        logger.info("Installing %d packages from %s", len(packages), self.packages_file)
        subprocess.run(["sudo", "apt", "install", "-y", *packages], check=True)
        logger.info("Development tools installed")

    def setup_dotfiles(self) -> None:
        """Clone or update the dotfiles repo, then run its install.sh.

        The remote URL is taken from the DOTFILES_REPO environment variable.
        When unset the user is prompted interactively.
        """
        logger.info("Setting up dotfiles...")

        repo = os.environ.get("DOTFILES_REPO", "").strip()
        if not repo:
            try:
                repo = input("Enter dotfiles repository URL: ").strip()
            except (EOFError, KeyboardInterrupt):
                print()

        if not repo:
            logger.error("No dotfiles repository provided")
            return

        if self.dotfiles_dir.is_dir():
            logger.warning("Dotfiles directory already exists at %s", self.dotfiles_dir)
            if confirm("Update existing dotfiles?"):
                subprocess.run(["git", "pull"], cwd=self.dotfiles_dir, check=True)
                logger.info("Dotfiles updated")
        else:
            logger.info("Cloning dotfiles from %s", repo)
            subprocess.run(["git", "clone", repo, str(self.dotfiles_dir)], check=True)
            logger.info("Dotfiles cloned")

        install_script = self.dotfiles_dir / "install.sh"
        if install_script.is_file():
            logger.info("Running dotfiles install script...")
            install_script.chmod(0o755)
            subprocess.run([str(install_script)], cwd=self.dotfiles_dir, check=True)
            logger.info("Dotfiles installed")
        else:
            logger.warning("No install.sh script found in dotfiles repository")

    def _select_applications(self, components: list[Application]) -> list[Application]:
        """Display a numbered menu and return the components the user chose.

        Args:
            components: All components available in the category.

        Returns:
            The subset selected by the user, possibly empty.
        """
        print()
        for idx, comp in enumerate(components, 1):
            badge = "[installed]" if comp.is_installed else "[not installed]"
            print(f"  {idx:2d}) {comp.name:<20s} {badge}")
        print()
        print("Selection options:")
        print("  a) Install all")
        print("  n) Install none")
        print("  #) Enter component numbers (e.g., 1,3,5 or 1-3 or 1 2 4)")
        print()

        try:
            raw = input("Select components to install: ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            return []

        if raw.lower() == "a":
            return components
        if raw.lower() == "n":
            return []
        return [components[i] for i in parse_selection(raw, len(components))]

    def install_applications(self, interactive: bool = True) -> None:
        """Discover, optionally select, and execute install.sh for a category.

        Args:
            interactive: When True the user picks components; otherwise every
                component is installed.
        """
        app_dir = self.script_dir / 'apps'
        if not app_dir.is_dir():
            logger.warning("No directory found at %s", app_dir)
            return

        platform = current_platform()
        applications = [
            c for c in discover_applications(app_dir) if platform in c.platforms
        ]
        if not applications:
            logger.info("No applications found for %s", platform)
            return

        selected_applications = self._select_applications(applications) if interactive else applications
        if not selected_applications:
            logger.info("No %s components selected for installation")
            return

        # Warn about dependencies that are neither selected nor already on PATH.
        selected_names = {c.name for c in selected_applications}
        for app in selected_applications:
            for dep in app.dependencies:
                if dep not in selected_names and not shutil.which(dep):
                    logger.warning(
                        "%s depends on %s which is not selected and not found in PATH",
                        app.name,
                        dep,
                    )

        selected_applications = resolve_order(selected_applications)
        logger.info("Installing %d application(s)", len(selected_applications))

        failed: dict[str, str] = {}  # name -> reason
        for app in selected_applications:
            broken_deps = [d for d in app.dependencies if d in failed]
            if broken_deps:
                logger.warning(
                    "Skipping %s: dependency %s failed",
                    app.name,
                    ", ".join(broken_deps),
                )
                failed[app.name] = "skipped — dependency failed"
                continue

            logger.info("Installing %s...", app.name)
            app.script.chmod(0o755)

            result = subprocess.run([str(app.script)], cwd=app.script.parent)
            if result.returncode != 0:
                logger.error("Failed: %s", app.name)
                failed[app.name] = "install failed"
                continue

            logger.info("Completed: %s", app.name)

            if not app.is_installed:
                missing = [a for a in app.artifacts if not shutil.which(a)]
                logger.error(
                    "Verification failed: %s — missing artifacts: %s",
                    app.name,
                    ", ".join(missing),
                )
                failed[app.name] = "verification failed"

        if failed:
            logger.error("The following applications failed:")
            for name, reason in failed.items():
                logger.error("  - %s (%s)", name, reason)
        else:
            logger.info("All install scripts completed successfully")

    def run_step(self, step: str, *, interactive: bool = True) -> None:
        """Execute a single named installation step.

        Args:
            step: One of the keys in STEPS.
            interactive: Forwarded to install_category for toolchains/apps.
        """
        dispatch = {
            "dirs": self.setup_dirs,
            "sysupgrade": self.sysupgrade,
            "devtools": self.install_devtools,
            "dotfiles": self.setup_dotfiles,
            "apps": lambda: self.install_applications(interactive=interactive),
        }
        dispatch[step]()


    def install_all(self) -> None:
        """Run every step non-interactively in canonical order."""
        logger.info("Running complete installation...")
        for step in STEPS:
            print()
            self.run_step(step, interactive=False)

    def install_custom(self) -> None:
        """Walk through each step, prompting the user before executing."""
        logger.info("Running custom installation...")
        for step in STEPS:
            print()
            if confirm(STEP_PROMPTS[step]):
                print()
                self.run_step(step, interactive=True)


def show_interactive_menu(genesis: Genesis) -> None:
    """Display the welcome menu and dispatch the user's choice.

    Args:
        genesis: The configured Genesis instance to operate on.
    """
    print("========================================")
    print("               Genesis                  ")
    print("========================================")
    print("1) Complete Installation (all steps)")
    print("2) Custom Installation (select steps)")
    print("3) Install Apps")
    print("4) Exit")
    print()

    try:
        choice = input("Select an option [1-4]: ").strip()
    except (EOFError, KeyboardInterrupt):
        choice = "4"

    if choice == "1":
        genesis.install_all()
    elif choice == "2":
        genesis.install_custom()
    elif choice == "3":
        genesis.install_applications(interactive=True)
    else:
        logger.info("Exiting...")
        sys.exit(0)


def main() -> None:
    """Entry point: parse flags, validate the platform, and run Genesis."""
    parser = argparse.ArgumentParser(
        prog="genesis",
        description="Development environment bootstrap for Ubuntu-based systems.",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--all",
        action="store_true",
        help="Complete installation – run every step without prompting.",
    )
    group.add_argument(
        "--custom",
        action="store_true",
        help="Custom installation – prompt before each step.",
    )
    group.add_argument(
        "--step",
        nargs="+",
        choices=STEPS,
        metavar="STEP",
        help=f"Run only the named step(s) in canonical order.  "
        f"Valid steps: {', '.join(STEPS)}",
    )
    parser.add_argument(
        "--log-level",
        default="WARNING",
        choices=("DEBUG", "INFO", "WARNING", "ERROR"),
        help="Set the logging verbosity (default: WARNING).",
    )
    args = parser.parse_args()

    logging.basicConfig(
        level=getattr(logging, args.log_level), format="[%(levelname)s] %(message)s"
    )

    # Warn and optionally abort when not running on an Ubuntu derivative
    try:
        content = Path("/etc/os-release").read_text().lower()
    except FileNotFoundError:
        content = ""

    if not any(tag in content for tag in ("ubuntu", "debian", "mint", "pop")):
        logger.warning("This script is designed for Ubuntu-based systems")
        if not confirm("Continue anyway?"):
            sys.exit(1)
    
    # 
    # Begin genesis
    #  
    genesis = Genesis(Path(__file__).resolve().parent)
    logger.info("Starting Genesis setup...")
    genesis.bootstrap()
    try:
        if args.all:
            genesis.install_all()
        elif args.custom:
            genesis.install_custom()
        elif args.step:
            # Execute requested steps in canonical order regardless of CLI order.
            requested = set(args.step)
            for step in STEPS:
                if step in requested:
                    print()
                    genesis.run_step(step, interactive=True)
        else:
            show_interactive_menu(genesis)
    except subprocess.CalledProcessError as exc:
        logger.error("Command failed (exit %d): %s", exc.returncode, exc.cmd)
        sys.exit(exc.returncode)
    except KeyboardInterrupt:
        print()
        logger.info("Interrupted by user")
        sys.exit(130)

    logger.info("Genesis setup complete!")
    logger.info("You may need to restart your shell or run: source ~/.bashrc")


if __name__ == "__main__":
    main()
